package certificate;

class Section046_snail {
	//2차원 배열 달팽이 모양으로 채우기
	public static void main(String[] args) {
		int k, c, i, j, f, n;
		//k = 배열에 저장할 값, c = 행과 열의 증가 혹은 감소 여부가 지정될 변수(스위치변수), i = 배열의 행 위치를 지정할 변수(첫번째 배열)
		//j = 배열의 열 위치를 저장할 변수(두번째 배열), f = 각 회전에서 수행할 수행 횟수가 지정될 변수, n = 반복분의 반복 변수
		int [][] a = new int[5][5];
		
		k = 0;	//1부터 저장하기 위해 0으로 초기화
		c = 1;	//스위치 변수, -1과 1을 반복함
		i = 0;	//배열 시작 번지는 0번지부터 시작하므로 0으로 초기화
		j = -1;	//하단의 J += c 를 수행한후 0이 되도록 -1로 초기화
		f = 5;	//수행횟수 5,4,3,2,1 순으로 감소한다.
		
		while(true) {	//조건이 참이므로 break문을 만나기 전까지 무한으로 반복한다.
			//확인용 출력의 주석을 풀어서 눈으로 확인해보자
			for (n = 1; n <= f; n++) {	//n이 1부터 5까지 1씩 증가하며 반복 총 5회 반복
				k++;	//저장될 데이터가 1씩 증가
				j += c;	//반복마다 1씩 증가하는 셈으로 1,2,3,4,5가 된다.
				a[i][j] = k;
				//첫번째 시행. a[0][0] = 1	/	a[0][1] = 2 ... , i가 고정된 상태로 열만 변한다.
				//두번째 시행. a[4][3] = 10/	a[4][2] = 11 ... , i가 고정된 상태로 열만 변한다.
//				System.out.println("첫번째 for문 " + a[i][j] + " j = " + j); //확인용 출력
			}
			
//			System.out.println("------------------------"); //확인용
			
			f--;	//1씩 감소하면서 열의 마지막이 줄어드는셈이 된다.
			
			if (f <= 0)	//배열의 번지수가 0보다 작을 수 없으니 0이되면 while문을 빠져나온다.
				break;
			
			for (n = 1; n <= f; n++) {	//위와 같은 반복
				k++;	//데이터 증가
				i += c;	//i는 행의 위치
				a[i][j] = k;
				//첫번째 시행. a[0][4] = 6	/	a[1][4] = 7 ... , j가 고정된 상태로 행만 변한다.
				//두번째 시행. a[3][0] = 14/	a[2][0] = 15 ... , j가 고정된 상태로 행만 변한다.
//				System.out.println("두번째 for문 " + a[i][j] + " i = " + i);	//확인용
			}
//			System.out.println("========================");	//확인용
			
			c *= -1;
		}	//while 끝
		
		for (int x = 0; x <= 4; x++) {
			for (int y = 0; y <= 4; y++)
				System.out.printf("%3d", a[x][y]);
			System.out.printf("\n");
		}
	}
}
